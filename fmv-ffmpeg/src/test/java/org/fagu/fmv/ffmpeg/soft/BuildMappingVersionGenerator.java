package org.fagu.fmv.ffmpeg.soft;

/*-
 * #%L
 * fmv-ffmpeg
 * %%
 * Copyright (C) 2014 - 2020 fagu
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.time.LocalDate;
import java.util.Collections;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;

import org.fagu.version.Version;
import org.fagu.version.VersionUnit;


/**
 * @author Oodrive
 * @author f.agu
 * @created 30 sept. 2019 09:52:11
 */
public class BuildMappingVersionGenerator {

	public static void main(String[] args) throws Exception {
		URL url = new URL("http://ffmpeg.org/releases/");
		Map<Version, LocalDate> map = new TreeMap<>(Collections.reverseOrder());
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()))) {
			Pattern pattern = Pattern.compile(".*href=\"ffmpeg-([0-9\\.]+)\\.tar\\.gz\".*(\\d{4})-(\\d{2})-(\\d{2}).*");
			reader.lines()
					.map(pattern::matcher)
					.filter(m -> m.matches())
					.forEach(s -> map.put(
							Version.parse(s.group(1)),
							LocalDate.of(Integer.parseInt(s.group(2)), Integer.parseInt(s.group(3)), Integer.parseInt(s.group(4)))));
		}

		System.out.println("// Generated by " + BuildMappingVersionGenerator.class.getName());
		System.out.println("// from http://ffmpeg.org/releases/");
		System.out.println();
		System.out.println("NavigableMap<Version, LocalDate> map = new TreeMap<>();");
		AtomicInteger mainVer = new AtomicInteger( - 1);
		map.forEach((ver, dat) -> {
			mainVer.getAndUpdate(prev -> {
				int v0 = ver.getFieldValue(VersionUnit.VF_0_MAJOR, - 1);
				if(prev == v0) {
					return prev;
				}
				System.out.println("// ==== " + v0 + ".x.x");
				return v0;
			});
			System.out.println(
					new StringBuilder()
							.append("map.put(new Version(").append(ver.toString().replace('.', ','))
							.append("), LocalDate.of(").append(dat.getYear()).append(", ").append(dat.getMonthValue())
							.append(", ").append(dat.getDayOfMonth()).append("));"));
		});
		System.out.println("return map;");
	}

}
